---
title: 初探CRC32
date: 2016-11-20 04:36:37
tags:
---
## 0x00 前言
本来是一道MISC，在通过``binwalk``之后，发现这个数据包不仅是多个文件拼成，而且有密码。
搁平常，这道题就是无解了，不过看了一些writeup才发现，另有玄机。


这是压缩包的内容，很明显提示了密码8位，这分分钟在暗示我们要爆破，然而爆破从何处入手？
关键点在于CRC32.

##0x01 关于CRC32
每个文件都有一个不同的CRC32的值，.CRC是块数据的计算值,比如对每一个文件进行压缩.在一个解压缩过程中,程序会从新计算解压文件
的CRC值,并且将之与从文件中读取的CRC值进行比对,如果值相同,那么正确.


在CRC32中, 会有1/2^32 的可能性发生对确认数据更改的校验错误.
<!--more-->

txt文本中的内容| CRC32的数值
---|---
1 | 83DCEFB7
01 | CF412436
2 | 1AD5BE0D
02| 5648758C
3 | 6DD28E9B
03 | 214F451A
4 | F3B61B38
04 | BF2BD0B9
5 | 84B12BAE
05 | C82CE02F
6 | 1DB87A14
06 | 5125B195
7 | 6ABF4A82
07 | 26228103
8 | FA005713
08 | B69D9C92
9 | 8D076785
09 | C19AAC04
10 | A15D25E1


很明显，没有重复的。(上面是ansi编码的时候测试的，utf-8的肯定和这个不一样。)

这说明不同字节的编码都是不同的~即使他们表达的意思在我们看来是一样的。

## 0x02 回到这道题上来
还是刚才这个图

.txt文件里有提示大小是8 而且原题题目已经提示是8个字节的密码。所以可以使用以下代码进行爆破。

原理简单易懂，懒得赘述了，不过我第一次写这个代码的时候不知道crc32，用的是zipfile模块。然后爆破10^8 次。想想就觉得很happy.不过最后竟然出了，我也是醉了。花了挺长时间的。

以下是后来看WP时发现的脚本：

```
import zlib
for i in xrange(0,100000000):
   	buf = str(i).rjust(8,'0')
   	#print buf
   	if zlib.crc32(buf) & 0xffffffff == 0xbacab29e:
       	print '',buf
```

关于位运算的一些理解，之后会再聊聊~我才发现好像位运算是算法进阶的起点啊~~
